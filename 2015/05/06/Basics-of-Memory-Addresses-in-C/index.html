<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


  <meta name="google-site-verification" content="VvyjvVXcJQa0QklHipu6pwm2PJGnnchIqX7s5JbbT_0" />



  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="C语言," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?50c15455e37f70aea674ff4a663eef27";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Basics of Memory Addresses in C // Kaola.me </title>
</head>

<body>
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Kaola.me</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              Basics of Memory Addresses in C
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-06
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/06/Basics-of-Memory-Addresses-in-C/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/06/Basics-of-Memory-Addresses-in-C/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body fmt">

      
      

      
        <h1 id="Memory_Addresses">Memory Addresses</h1><p>It is helpful to think of everything in C in terms of computer memory. Let’s think of computer memory as an array of bytes where each address in memory holds 1 byte. If our computer has 4K of memory for example, it would have 4096 elements in the memory array. When we talk about pointers storing addresses, we are talking about a pointer storing an index to an element in the memory array. Dereferencing a pointer would be getting the value at that index in the array. All of this is of course a lie. How operating systems handle memory is much more complex than this. Memory is not necessarily contiguous and it is not necessarily handed out sequentially. But the analogy provides an easy way to think about memory in C to get started.<br><a id="more"></a><br>Confused about pointers, addresses and dereferencing? Take a look at this 5-Minute Guide to Pointers.</p>
<p>Say our computer has 4K of memory and the next open address is index 2048. We declare a new char variable i = ‘a’. When the variable gets declared memory is set aside for its value and the variable name is linked to that location in memory. Our char i has a value ‘a’ stored at the address 2048. Our char is a single byte so it only takes up index 2048. If we use the address-of operator (&amp;) on our variable i it would return the address 2048. If the variable was a different type, int for instance, it would take up 4 bytes and use up elements 2048-2051 in the array. Using the address-of operator would still return 2048 though because the int starts at that index even though it takes up 4 bytes. Let’s look at an example.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intialize a char variable, print its address and the next address</span></span><br><span class="line"><span class="keyword">char</span> charvar = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of charvar = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;charvar));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of charvar - 1 = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;charvar - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of charvar + 1 = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;charvar + <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// intialize an int variable, print its address and the next address</span></span><br><span class="line"><span class="keyword">int</span> intvar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of intvar = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;intvar));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of intvar - 1 = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;intvar - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of intvar + 1 = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;intvar + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>Running that you should get output like the following:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">address</span> of charvar = <span class="number">0</span>x7fff9575c05f</span><br><span class="line"><span class="tag">address</span> of charvar - <span class="number">1</span> = <span class="number">0</span>x7fff9575c05e</span><br><span class="line"><span class="tag">address</span> of charvar + <span class="number">1</span> = <span class="number">0</span>x7fff9575c060</span><br><span class="line"><span class="tag">address</span> of intvar = <span class="number">0</span>x7fff9575c058</span><br><span class="line"><span class="tag">address</span> of intvar - <span class="number">1</span> = <span class="number">0</span>x7fff9575c054</span><br><span class="line"><span class="tag">address</span> of intvar + <span class="number">1</span> = <span class="number">0</span>x7fff9575c05c</span><br></pre></td></tr></table></figure>
<p>In the first example on lines 1-5 we declare a char variable, print out the address-of the char, and then print out the address just before and just after the char in memory. We get the addresses before and after by getting the using the &amp; operator and then adding or subtracting one. In the second example on lines 7-11 we do the same thing except this time we declare an int variable, printing out its address and the addresses right before and after it.</p>
<p>In the output we see the addresses in hexadecimal. What is important to notice is that the char addresses are 1 byte before and after while the int the addresses are 4 bytes before and after. Math on memory addresses, pointer math, is based on the sizeof the type being referenced. The size of a given type is platform dependent but for this example our char takes 1 byte and our int takes 4 bytes. Subtracting 1 address from a char gives a memory address that is 1 byte previous while subtracting 1 from an int gives a memory address that is 4 bytes previous.</p>
<p>Even though in our example we were using the address-of operator to get the addresses of our variables, the operations are the same when using pointers that hold the address-of a varible.</p>
<p>Some commenters have brought up that storing &amp;charvar – 1, an invalid address because it is before the array, is technically unspecified behavior. This is true. The C standard does have areas that are unspecified and on some platforms even storing an invalid address will cause an error.</p>
<h1 id="Array_Addresses">Array Addresses</h1><p>Arrays in C are contiguous memory areas that hold a number of values of the same data type (int, long, *char, etc.). Many programmers when they first use C think arrays are pointers. That isn’t true. A pointer stores a single memory address, an array is a contiguous area of memory that stores multiple values.</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// initialize an<span class="instruction"> array </span>of ints<span class="instruction"></span><br><span class="line">int </span>numbers<span class="keyword">[</span>5] = &#123;1,2,3,4,5&#125;;<span class="instruction"></span><br><span class="line">int </span>i = 0;</span><br><span class="line"> </span><br><span class="line">// print the address of the<span class="instruction"> array </span>variable</span><br><span class="line">printf(<span class="string">"numbers = %p\n"</span>, numbers<span class="function">)</span>;</span><br><span class="line"> </span><br><span class="line">// print addresses of each<span class="instruction"> array </span>index</span><br><span class="line">do &#123;</span><br><span class="line">   <span class="function"> printf(</span><span class="string">"numbers[%u] = %p\n"</span>, i,<span class="function"> (</span>void<span class="function"> *)(</span>&amp;numbers<span class="keyword">[</span>i]<span class="function">)</span><span class="function">)</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;<span class="function"> while(</span>i &lt; 5<span class="function">)</span>;</span><br><span class="line"> </span><br><span class="line">// print the size of the<span class="instruction"> array</span><br><span class="line"></span>printf(<span class="string">"sizeof(numbers) = %lu\n"</span>,<span class="function"> sizeof(</span>numbers<span class="function">)</span><span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>Running that you should get output like the following:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="number">0x7fff0815c0e0</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">0x7fff0815c0e0</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">0x7fff0815c0e4</span></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">0x7fff0815c0e8</span></span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">0x7fff0815c0ec</span></span><br><span class="line">numbers[<span class="number">4</span>] = <span class="number">0x7fff0815c0f0</span></span><br><span class="line">sizeof(numbers) = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>In this example we initialize an array of 5 ints. We then print the address of the array itself. Notice we didn’t use the address-of &amp; operator. This is because the array variable already decays to the address of the first element in the array. As you can see the address of the array and the address of the first element in the array are the same. Then we loop through the array and print out the memory addresses at each index. Each int is 4 bytes on our computer and array memory is contiguous, so each int addres be 4 bytes away from each other.</p>
<p>In the last line we print the size of the array. The size of an array is the sizeof(type) * number of elements in the array. Here the array holds 5 ints, each of which takes up 4 bytes. The entire array is 20 bytes.</p>
<h1 id="Struct_Addresses">Struct Addresses</h1><p>Structs in C tend to be contiguous memory areas, though not always. And like arrays they hold multiple data types, but unlike arrays they can hold a different data types.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> measure &#123;</span><br><span class="line">  <span class="keyword">char</span> category;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declare and populate the struct</span></span><br><span class="line"><span class="keyword">struct</span> measure ball;</span><br><span class="line">ball.category = <span class="string">'C'</span>;</span><br><span class="line">ball.width = <span class="number">5</span>;</span><br><span class="line">ball.height = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// print the addresses of the struct and its members</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of ball = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;ball));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of ball.category = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;ball.category));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of ball.width = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;ball.width));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of ball.height = %p\n"</span>, (<span class="keyword">void</span> *)(&amp;ball.height));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// print the size of the struct</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(ball) = %lu\n"</span>, <span class="keyword">sizeof</span>(ball));</span><br></pre></td></tr></table></figure>
<p>Running that you should get output like the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">address</span> of ball = <span class="number">0</span>x7fffd1510060</span><br><span class="line"><span class="tag">address</span> of ball<span class="class">.category</span> = <span class="number">0</span>x7fffd1510060</span><br><span class="line"><span class="tag">address</span> of ball<span class="class">.width</span> = <span class="number">0</span>x7fffd1510064</span><br><span class="line"><span class="tag">address</span> of ball<span class="class">.height</span> = <span class="number">0</span>x7fffd1510068</span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(ball)</span></span> = <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>In this example we have our struct definition. Then we declare a instance ball of the struct measure and we populate its width, height, and category members with values. Then we print out the address of the ball variable. Like the array varible structs decay to the address of their first element. We then print out each of the struct members. Category is the is the first member and we see that it has the same address as the ball variable. The width member is next followed by the height member. Both have address higher than the category member.</p>
<p>You might think that because category is a char and chars take up 1 byte then the width member should be at an address 1 byte higher than the start. As you can see from the output this isn’t the case. According to the C99 standard (C99 §6.7.2.1), a C implementation can add padding bytes to members for aligment on byte boundaries. It cannot reorder the data members but it can add in padding bytes. In practice most compilers will make each member the same size as the largest member in the struct but this is entirely implementatation specific.</p>
<p>In our example you can see that the char actually takes up 4 bytes and the size of the struct takes a total of 12 bytes. What to take away? </p>
<pre><code>*A struct <span class="built_in">variable</span> points <span class="built_in">to</span> <span class="operator">the</span> address <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">first</span> member <span class="operator">in</span> <span class="operator">the</span> struct.
*Don’t assume that struct members will be <span class="operator">a</span> specific <span class="built_in">number</span> <span class="operator">of</span> <span class="keyword">bytes</span> away <span class="built_in">from</span> another field, they may have padding <span class="keyword">bytes</span> <span class="operator">or</span> <span class="operator">the</span> memory might <span class="operator">not</span> be contiguous depending <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">implementation</span>. <span class="title">Use</span> <span class="title">the</span> <span class="title">address-of</span> (&amp;) <span class="title">operator</span> <span class="title">on</span> <span class="title">the</span> <span class="title">member</span> <span class="title">to</span> <span class="title">get</span> <span class="title">its</span> <span class="title">address</span>.</span>
*And use sizeof(struct instance) <span class="built_in">to</span> <span class="built_in">get</span> <span class="operator">the</span> total size <span class="operator">of</span> <span class="operator">the</span> struct, don’t assume <span class="keyword">it</span> is just <span class="operator">the</span> <span class="built_in">sum</span> <span class="operator">of</span> its member fields, <span class="keyword">it</span> may have padding.
</code></pre><h1 id="Conclusion">Conclusion</h1><p>Hope this post helps you to understand more about how addresses operate on different data types in C. In a future post we will go over some basics on pointers and arrays in C.</p>
<p>Update 1:Thanks to Sorito, I added a link back to blog post about pointers, addresses, and dereferencing.<br>Update 2:Thanks to Keith Thompson and tjoff from hacker news for helping clarify struct addresses and memory. I reworked the example code to be more clear about memory.</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C语言/"> #C语言 </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/20/Tclip/">Tclip</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
          <div class="ds-thread" data-thread-key="2015/05/06/Basics-of-Memory-Addresses-in-C/"
               data-title="Basics of Memory Addresses in C" data-url="http://www.kaola.me/2015/05/06/Basics-of-Memory-Addresses-in-C/">
          </div>
        
      </div>
    
  </div>


        </div>
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Leilei·Yan" />
          <p class="site-author-name">Leilei·Yan</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/anley/" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/kaolame" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.kaola.me" target="_blank">Blog</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="mailto:admin@kaola.me" target="_blank">Email</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory_Addresses"><span class="nav-number">1.</span> <span class="nav-text">Memory Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array_Addresses"><span class="nav-number">2.</span> <span class="nav-text">Array Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Struct_Addresses"><span class="nav-number">3.</span> <span class="nav-text">Struct Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">4.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2011 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Leilei·Yan</span>
</div>

<div class="powered-by">
  生活是一种态度
</div>

<div class="theme-info">
  雷雷 -
  <a class="theme-link" href="https://www.kaola.me">
    Leilei·Yan
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  
  
<script type="text/javascript" id="bootstrap.scrollspy.custom">
  /* ========================================================================
  * Bootstrap: scrollspy.js v3.3.2
  * http://getbootstrap.com/javascript/#scrollspy
  * ========================================================================
  * Copyright 2011-2015 Twitter, Inc.
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  * ======================================================================== */

  /**
   * Custom by iissnan
   *
   * - Add a `clear.bs.scrollspy` event.
   * - Esacpe targets selector.
   */


  +function ($) {
    'use strict';

    // SCROLLSPY CLASS DEFINITION
    // ==========================

    function ScrollSpy(element, options) {
      this.$body          = $(document.body)
      this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
      this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
      this.selector       = (this.options.target || '') + ' .nav li > a'
      this.offsets        = []
      this.targets        = []
      this.activeTarget   = null
      this.scrollHeight   = 0

      this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
      this.refresh()
      this.process()
    }

    ScrollSpy.VERSION  = '3.3.2'

    ScrollSpy.DEFAULTS = {
      offset: 10
    }

    ScrollSpy.prototype.getScrollHeight = function () {
      return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }

    ScrollSpy.prototype.refresh = function () {
      var that          = this
      var offsetMethod  = 'offset'
      var offsetBase    = 0

      this.offsets      = []
      this.targets      = []
      this.scrollHeight = this.getScrollHeight()

      if (!$.isWindow(this.$scrollElement[0])) {
        offsetMethod = 'position'
        offsetBase   = this.$scrollElement.scrollTop()
      }

      this.$body
        .find(this.selector)
        .map(function () {
          var $el   = $(this)
          var href  = $el.data('target') || $el.attr('href')
          var $href = /^#./.test(href) && $(escapeSelector(href)) // Need to escape selector.

          return ($href
            && $href.length
            && $href.is(':visible')
            && [[$href[offsetMethod]().top + offsetBase, href]]) || null
        })
        .sort(function (a, b) { return a[0] - b[0] })
        .each(function () {
          that.offsets.push(this[0])
          that.targets.push(this[1])
        })


    }

    ScrollSpy.prototype.process = function () {
      var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
      var scrollHeight = this.getScrollHeight()
      var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
      var offsets      = this.offsets
      var targets      = this.targets
      var activeTarget = this.activeTarget
      var i

      if (this.scrollHeight != scrollHeight) {
        this.refresh()
      }

      if (scrollTop >= maxScroll) {
        return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
      }

      if (activeTarget && scrollTop < offsets[0]) {
        $(this.selector).trigger('clear.bs.scrollspy')  // Add a custom event.
        this.activeTarget = null
        return this.clear()
      }

      for (i = offsets.length; i--;) {
        activeTarget != targets[i]
          && scrollTop >= offsets[i]
          && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
          && this.activate(targets[i])
      }
    }

    ScrollSpy.prototype.activate = function (target) {
      this.activeTarget = target

      this.clear()

      var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

      var active = $(selector)
        .parents('li')
        .addClass('active')

      if (active.parent('.dropdown-menu').length) {
        active = active
          .closest('li.dropdown')
          .addClass('active')
      }

      active.trigger('activate.bs.scrollspy')
    }

    ScrollSpy.prototype.clear = function () {
      $(this.selector)
        .parentsUntil(this.options.target, '.active')
        .removeClass('active')
    }


    // SCROLLSPY PLUGIN DEFINITION
    // ===========================

    function Plugin(option) {
      return this.each(function () {
        var $this   = $(this)
        var data    = $this.data('bs.scrollspy')
        var options = typeof option == 'object' && option

        if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
        if (typeof option == 'string') data[option]()
      })
    }

    var old = $.fn.scrollspy

    $.fn.scrollspy             = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy


    // SCROLLSPY NO CONFLICT
    // =====================

    $.fn.scrollspy.noConflict = function () {
      $.fn.scrollspy = old
      return this
    }


    // SCROLLSPY DATA-API
    // ==================

    $(window).on('load.bs.scrollspy.data-api', function () {
      $('[data-spy="scroll"]').each(function () {
        var $spy = $(this)
        Plugin.call($spy, $spy.data())
      })
    })

  }(jQuery);
</script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0 && isDesktop()) {
        setTimeout(function () {
          $('.sidebar-toggle').trigger('click');
        }, 800);
      }
    });
  </script>




  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"kaolame"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
</body>
</html>
